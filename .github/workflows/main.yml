name: ci
on:
  push:
    branches:
      - main
  pull_request:
  workflow_dispatch:
  release:
    types: [published]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  id-token: write
  contents: read

jobs:
  nix-check:
    name: nix flake check
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Install Nix
        uses: nixbuild/nix-quick-install-action@8505cd40ae3d4791ca658f2697c5767212e5ce71
        with:
          nix_conf: |
            experimental-features = nix-command flakes
            accept-flake-config = true
            keep-env-derivations = true
            keep-outputs = true
      - name: Restore and save Nix store
        uses: nix-community/cache-nix-action@76f6697d63b7378f7161d52f3d81784130ecd90d
        with:
          primary-key: nix-${{ runner.os }}-${{ hashFiles('**/*.nix', '**/flake.lock') }}
          restore-prefixes-first-match: nix-${{ runner.os }}-
      - name: nix flake check
        run: nix flake check --no-pure-eval --all-systems --accept-flake-config -L

  checks:
    name: validate and test
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_USER: root
          POSTGRES_PASSWORD: mysecretpassword
          POSTGRES_DB: local
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    env:
      DATABASE_URL: postgres://root:mysecretpassword@localhost:5432/local
      DATABASE_URL_TEST: postgres://root:mysecretpassword@localhost:5432/local_test

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - uses: pnpm/action-setup@d648c2dd069001a242c621c8306af467f150e99d

      - name: Use Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: package.json
          cache: "pnpm"

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install browsers
        run: pnpm exec playwright install

      - name: Copy .env example
        run: cp .env.example .env

      - name: Migrate db schema
        run: pnpm db:migrate

      - name: Lint
        run: pnpm lint

      - name: Generate i18n files
        run: pnpm i18n:generate

      - name: Check
        run: pnpm check

      - name: Test
        run: pnpm test

  build:
    needs: nix-check
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres
        env:
          POSTGRES_USER: root
          POSTGRES_PASSWORD: mysecretpassword
          POSTGRES_DB: local
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - name: Install Nix
        uses: nixbuild/nix-quick-install-action@8505cd40ae3d4791ca658f2697c5767212e5ce71
        with:
          nix_conf: |
            experimental-features = nix-command flakes
            accept-flake-config = true
            keep-env-derivations = true
            keep-outputs = true
      - name: Restore and save Nix store
        uses: nix-community/cache-nix-action@76f6697d63b7378f7161d52f3d81784130ecd90d
        with:
          primary-key: nix-${{ runner.os }}-${{ hashFiles('**/*.nix', '**/flake.lock') }}
          restore-prefixes-first-match: nix-${{ runner.os }}-
      - name: nix build
        run: nix build . --accept-flake-config -L
      - name: Load Docker image
        run: nix build .#docker --accept-flake-config -L && docker load < result
      - name: Save Docker image as artifact
        run: docker save rekisteri:latest | gzip > rekisteri-docker-image.tar.gz
      - name: Upload Docker image
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: rekisteri-docker-image.tar.gz
          retention-days: 1
      - name: Sanity check - Start app with migrations
        run: |
          # Run container in background with database connection
          docker run -d --name rekisteri-test \
            --network host \
            -e CI=true \
            -e DATABASE_URL=postgres://root:mysecretpassword@localhost:5432/local \
            -e PUBLIC_URL=http://localhost:5173 \
            -e STRIPE_API_KEY=sk_test_... \
            -e STRIPE_WEBHOOK_SECRET=whsec_... \
            -e MAILGUN_API_KEY=... \
            -e MAILGUN_DOMAIN=rekisteri.tietokilta.fi \
            -e MAILGUN_SENDER="TiK-Rekisteri <noreply@rekisteri.tietokilta.fi>" \
            -e MAILGUN_URL="https://api.eu.mailgun.net" \
            rekisteri:latest

          # Wait for app to start (migrations + server startup)
          # The startup script should fail fast if migrations fail
          echo "Waiting for app to start..."
          for i in {1..30}; do
            if docker logs rekisteri-test 2>&1 | grep -q "Listening on"; then
              echo "✓ App started successfully!"
              docker logs rekisteri-test

              # Verify the server is healthy and database is connected
              echo ""
              echo "Testing health endpoint..."
              HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/health || echo "000")

              if [ "$HTTP_CODE" = "200" ]; then
                echo "✓ Health check passed (HTTP 200)"
                # Show the health response for debugging
                curl -s http://localhost:3000/api/health | jq '.' || true
                docker stop rekisteri-test
                exit 0
              else
                echo "✗ Health check failed with HTTP $HTTP_CODE (expected 200)"
                curl -s http://localhost:3000/api/health | jq '.' || true
                docker logs rekisteri-test
                docker stop rekisteri-test
                exit 1
              fi
            fi
            if ! docker ps | grep -q rekisteri-test; then
              echo "✗ Container stopped unexpectedly"
              docker logs rekisteri-test
              exit 1
            fi
            sleep 1
          done

          echo "✗ App did not start within 30 seconds"
          docker logs rekisteri-test
          exit 1

  docker-build-and-publish:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    needs: [checks, build]
    name: Push Docker image to GitHub Packages
    runs-on: ubuntu-latest
    permissions:
      packages: write
      contents: read
    steps:
      - name: Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image
      - name: Load Docker image
        run: docker load < rekisteri-docker-image.tar.gz
      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - name: Tag and push docker image
        run: |
          docker tag rekisteri:latest ghcr.io/tietokilta/rekisteri:latest
          docker tag rekisteri:latest ghcr.io/tietokilta/rekisteri:sha-${{ github.sha }}
          docker push ghcr.io/tietokilta/rekisteri:latest
          docker push ghcr.io/tietokilta/rekisteri:sha-${{ github.sha }}

  deploy:
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    name: Deploy to Azure
    runs-on: ubuntu-latest
    needs: docker-build-and-publish
    steps:
      - name: Login via Azure CLI
        uses: azure/login@v2
        with:
          client-id: ${{secrets.AZURE_CLIENT_ID}}
          subscription-id: ${{secrets.AZURE_SUBSCRIPTION_ID}}
          tenant-id: ${{secrets.AZURE_TENANT_ID}}
      - uses: azure/webapps-deploy@v3
        with:
          app-name: tik-registry-prod
          images: "ghcr.io/tietokilta/rekisteri:sha-${{ github.sha }}"
